<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MQTT-SN Gateway Library: Session</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MQTT-SN Gateway Library
   </div>
   <div id="projectbrief">Library that allows implementation of MQTT-SN gateway.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Session</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cc_mqttsn_gw_session_page_alloc">Allocation</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_recv">Receiving Data</a><ul><li class="level2"><a href="#cc_mqttsn_gw_session_page_recv_client">Receiving Data from Client</a></li>
<li class="level2"><a href="#cc_mqttsn_gw_session_page_recv_broker">Receiving Data from Broker</a></li>
</ul>
</li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_send">Sending Data</a><ul><li class="level2"><a href="#cc_mqttsn_gw_session_page_send_client">Sending Data to Client</a></li>
<li class="level2"><a href="#cc_mqttsn_gw_session_page_send_broker">Sending Data to Broker</a></li>
</ul>
</li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_time">Time Measurement</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_term">Session Termination</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_broker_reconnect">Re-Connection to Broker</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_id">Gateway ID</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_retry">Retry Attempts</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_predefined_topics">Predefined Topics</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_topics_registration">Allocating Topic IDs</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_start">Start Operation</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_broker_conn">Connection to Broker</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_client_auth">Client Authentication</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_connected_client">Connected Client Report</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_default_client_id">Default Client ID</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_publish_only">Publish Only Client</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_sleep">Sleeping Client</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_fwd_enc">Forwarder Encapsulation Support</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_error_report">Errors Report</a></li>
</ul>
</div>
<div class="textblock"><p>The <b>Session</b> object is responsible to manage and forward traffic of messages between <b>single</b> MQTT-SN client and the broker. When new message is received over the I/O link, the driving code must check whether any <b>Session</b> object has already been created for the client that sent the message (the clients can be differentiated by their origin address). If such <b>Session</b> does NOT exist, it must be created.</p>
<p>The received data needs to be forwarded to appropriate <b>Session</b> object for processing. And when the <b>Session</b> object requests to send message back, it needs to be sent to the right address. It is a responsibility of the driving code to maintain a valid map between the client's address and appropriate <b>Session</b> object.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_alloc"></a>
Allocation</h1>
<p>When using <b>C++</b> interface, just instantiate object of <a class="el" href="classcc__mqttsn__gateway_1_1Session.html" title="Interface for Session entity.">cc_mqttsn_gateway::Session</a> class. The destruction of the object will clean up all acquired resources. </p><div class="fragment"><div class="line">std::unique_ptr&lt;cc_mqttsn_gateway::Session&gt; session(<span class="keyword">new</span> <a class="code hl_class" href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a>());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Using raw pointer to force doxygen to propely generate links to the </span></div>
<div class="line"><span class="comment">// member functions in the code snippets below.</span></div>
<div class="line"><a class="code hl_class" href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a>* session = <span class="keyword">new</span> <a class="code hl_class" href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a></div><div class="ttdoc">Interface for Session entity.</div><div class="ttdef"><b>Definition</b> Session.h:29</div></div>
</div><!-- fragment --><p>When using <b>C</b> interface, the allocation is performed using <a class="el" href="gateway__all_8h.html#a5c78e0c26c7400fa6508f6f51522f144" title="Allocate Session object.">cc_mqttsn_gw_session_alloc()</a> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> handle = <a class="code hl_function" href="gateway__all_8h.html#a5c78e0c26c7400fa6508f6f51522f144">cc_mqttsn_gw_session_alloc</a>();</div>
<div class="ttc" id="agateway__all_8h_html_a1a903f928f9f0166dd06326da57aa0d0"><div class="ttname"><a href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a></div><div class="ttdeci">struct CC_MqttsnSession * CC_MqttsnSessionHandle</div><div class="ttdoc">Handle for session object used in all cc_mqttsn_gw_session_* functions.</div><div class="ttdef"><b>Definition</b> gateway_all.h:123</div></div>
<div class="ttc" id="agateway__all_8h_html_a5c78e0c26c7400fa6508f6f51522f144"><div class="ttname"><a href="gateway__all_8h.html#a5c78e0c26c7400fa6508f6f51522f144">cc_mqttsn_gw_session_alloc</a></div><div class="ttdeci">CC_MqttsnSessionHandle cc_mqttsn_gw_session_alloc(void)</div><div class="ttdoc">Allocate Session object.</div></div>
</div><!-- fragment --><p> and de-allocation is performed using <a class="el" href="gateway__all_8h.html#a988a27a795d74e569fe9be3dd93fbf2a" title="Free allocated Session object.">cc_mqttsn_gw_session_free()</a> functions. </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#a988a27a795d74e569fe9be3dd93fbf2a">cc_mqttsn_gw_session_free</a>(handle);</div>
<div class="ttc" id="agateway__all_8h_html_a988a27a795d74e569fe9be3dd93fbf2a"><div class="ttname"><a href="gateway__all_8h.html#a988a27a795d74e569fe9be3dd93fbf2a">cc_mqttsn_gw_session_free</a></div><div class="ttdeci">void cc_mqttsn_gw_session_free(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Free allocated Session object.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_recv"></a>
Receiving Data</h1>
<p>The MQTT-SN gateway <b>Session</b> serves as message translator and forwarder between MQTT-SN client and MQTT broker. The driver code is responsible to manage these two independent communication links. Once a message is received on any of them, it must be provided the the <b>Session</b> object for processing.</p>
<h2><a class="anchor" id="cc_mqttsn_gw_session_page_recv_client"></a>
Receiving Data from Client</h2>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">std::size_t consumed = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a3ef4bfb2e5c6d6768ba1b9ef75e82f93">dataFromClient</a>(buf, bufLen);</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a3ef4bfb2e5c6d6768ba1b9ef75e82f93"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a3ef4bfb2e5c6d6768ba1b9ef75e82f93">cc_mqttsn_gateway::Session::dataFromClient</a></div><div class="ttdeci">std::size_t dataFromClient(const std::uint8_t *buf, std::size_t len)</div><div class="ttdoc">Provide data received from the client for processing.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> consumed = <a class="code hl_function" href="gateway__all_8h.html#a9cd75cfcd9fc320610c1747ece2aeb83">cc_mqttsn_gw_session_data_from_client</a>(handle, buf, bufLen);</div>
<div class="ttc" id="agateway__all_8h_html_a9cd75cfcd9fc320610c1747ece2aeb83"><div class="ttname"><a href="gateway__all_8h.html#a9cd75cfcd9fc320610c1747ece2aeb83">cc_mqttsn_gw_session_data_from_client</a></div><div class="ttdeci">unsigned cc_mqttsn_gw_session_data_from_client(CC_MqttsnSessionHandle session, const unsigned char *buf, unsigned bufLen)</div><div class="ttdoc">Provide data received from the client for processing.</div></div>
</div><!-- fragment --><p><b>NOTE</b>, that functions return number of bytes that were actually processed. If number of processed bytes is less that number of bytes residing in the buffer, then probably some unexpected protocol error has occurred.</p>
<p>The call to this function may cause invocation of various callback functions that have been set.</p>
<h2><a class="anchor" id="cc_mqttsn_gw_session_page_recv_broker"></a>
Receiving Data from Broker</h2>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">std::size_t consumed = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a728ac52d1c104c446c5c4b059d16d9e1">dataFromBroker</a>(buf, bufLen);</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a728ac52d1c104c446c5c4b059d16d9e1"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a728ac52d1c104c446c5c4b059d16d9e1">cc_mqttsn_gateway::Session::dataFromBroker</a></div><div class="ttdeci">std::size_t dataFromBroker(const std::uint8_t *buf, std::size_t len)</div><div class="ttdoc">Provide data received from the broker for processing.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> consumed = <a class="code hl_function" href="gateway__all_8h.html#add5b16f698d0ff7af1add101f9386c56">cc_mqttsn_gw_session_data_from_broker</a>(handle, buf, bufLen);</div>
<div class="ttc" id="agateway__all_8h_html_add5b16f698d0ff7af1add101f9386c56"><div class="ttname"><a href="gateway__all_8h.html#add5b16f698d0ff7af1add101f9386c56">cc_mqttsn_gw_session_data_from_broker</a></div><div class="ttdeci">unsigned cc_mqttsn_gw_session_data_from_broker(CC_MqttsnSessionHandle session, const unsigned char *buf, unsigned bufLen)</div><div class="ttdoc">Provide data received from the broker for processing.</div></div>
</div><!-- fragment --><p><b>NOTE</b>, that functions return number of bytes that were actually processed. If number of processed bytes is less that number of bytes residing in the buffer, then probably some unexpected protocol error has occurred.</p>
<p>The call to this function may cause invocation of various callback functions that have been set.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_send"></a>
Sending Data</h1>
<p>The <b>Session</b> object may require to send a message to either client or broker. The driving code has to provide appropriate callbacks for this purpose. When the callback is invoked, it is provided with pointer to data buffer. This buffer resides in internal data structures of the <b>Session</b> object. After the callback returns, this buffer may be updated. It means, that the driving code may require to copy the buffer to its internal data structures to preserve the data intact until send over I/O link operation is complete.</p>
<h2><a class="anchor" id="cc_mqttsn_gw_session_page_send_client"></a>
Sending Data to Client</h2>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#abb4228612f45bc52de3d62be40f28c29">setSendDataClientReqCb</a>(</div>
<div class="line">    [](<span class="keyword">const</span> std::uint8_t* buf, std::size_t bufLen)</div>
<div class="line">    {</div>
<div class="line">        ... </div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_abb4228612f45bc52de3d62be40f28c29"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#abb4228612f45bc52de3d62be40f28c29">cc_mqttsn_gateway::Session::setSendDataClientReqCb</a></div><div class="ttdeci">void setSendDataClientReqCb(ClientSendDataReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when new data needs to be sent to the client.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_send_to_client(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> session, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> bufLen)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#ac360b1fc3f387ba822c0017a061b79dd">cc_mqttsn_gw_session_set_send_data_to_client_cb</a>(handle, &amp;my_send_to_client, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_ac360b1fc3f387ba822c0017a061b79dd"><div class="ttname"><a href="gateway__all_8h.html#ac360b1fc3f387ba822c0017a061b79dd">cc_mqttsn_gw_session_set_send_data_to_client_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_send_data_to_client_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionClientSendDataReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when new data needs to be sent to the client.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="cc_mqttsn_gw_session_page_send_broker"></a>
Sending Data to Broker</h2>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a230c8f69e352f9314286990f5d0979f4">setSendDataBrokerReqCb</a>(</div>
<div class="line">    [](<span class="keyword">const</span> std::uint8_t* buf, std::size_t bufLen)</div>
<div class="line">    {</div>
<div class="line">        ... </div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a230c8f69e352f9314286990f5d0979f4"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a230c8f69e352f9314286990f5d0979f4">cc_mqttsn_gateway::Session::setSendDataBrokerReqCb</a></div><div class="ttdeci">void setSendDataBrokerReqCb(BrokerSendDataReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when new data needs to be sent to the broker.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_send_to_broker(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> session, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> bufLen)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a25285e430dfe8e094448a6f97497191f">cc_mqttsn_gw_session_set_send_data_to_broker_cb</a>(handle, &amp;my_send_to_broker, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a25285e430dfe8e094448a6f97497191f"><div class="ttname"><a href="gateway__all_8h.html#a25285e430dfe8e094448a6f97497191f">cc_mqttsn_gw_session_set_send_data_to_broker_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_send_data_to_broker_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionBrokerSendDataReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when new data needs to be sent to the broker.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_time"></a>
Time Measurement</h1>
<p>The <b>Session</b> object may require to measure time to identify message delivery timeouts. It relies on the driving code to provide such service. There is a need to set appropriate callback:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session.<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#ad03abf3c8beaad947016bea6a5e66d85">setNextTickProgramReqCb</a>(</div>
<div class="line">    [](<span class="keywordtype">unsigned</span> duration)</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// Set timer to expire after duration milliseconds</span></div>
<div class="line">            <span class="comment">// After expiry call session.tick()</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ad03abf3c8beaad947016bea6a5e66d85"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ad03abf3c8beaad947016bea6a5e66d85">cc_mqttsn_gateway::Session::setNextTickProgramReqCb</a></div><div class="ttdeci">void setNextTickProgramReqCb(NextTickProgramReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when new time measurement is required.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_tick_req(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> session, <span class="keywordtype">unsigned</span> duration)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* Set timer to expire after duration milliseconds */</span></div>
<div class="line">    ... <span class="comment">/* After expiry call cc_mqttsn_gw_session_tick() */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a9a29a45cb621da2a929ce19aae3c0e35">cc_mqttsn_gw_session_set_tick_req_cb</a>(handle, &amp;my_tick_req, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a9a29a45cb621da2a929ce19aae3c0e35"><div class="ttname"><a href="gateway__all_8h.html#a9a29a45cb621da2a929ce19aae3c0e35">cc_mqttsn_gw_session_set_tick_req_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_tick_req_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionTickReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when new time measurement is required.</div></div>
</div><!-- fragment --><p>After the requested time expires, the driving code needs to notify the <b>Session</b> object. It must call the appropriate <b>tick()</b> function.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a3d3c252c3b9aa9572d2f8f52a4fee3a6">tick</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a3d3c252c3b9aa9572d2f8f52a4fee3a6"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a3d3c252c3b9aa9572d2f8f52a4fee3a6">cc_mqttsn_gateway::Session::tick</a></div><div class="ttdeci">void tick()</div><div class="ttdoc">Notify the Session object about requested time period expiry.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#a5e128249938a69f3c858adab44e81142">cc_mqttsn_gw_session_tick</a>(handle); </div>
<div class="ttc" id="agateway__all_8h_html_a5e128249938a69f3c858adab44e81142"><div class="ttname"><a href="gateway__all_8h.html#a5e128249938a69f3c858adab44e81142">cc_mqttsn_gw_session_tick</a></div><div class="ttdeci">void cc_mqttsn_gw_session_tick(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Notify the Session object about requested time period expiry.</div></div>
</div><!-- fragment --><p>Based on some events, the <b>Session</b> object may require knowledge of elapsed time since last tick programming request. For this purpose the driving code must set a callback to cancel the existing time measurement and return number of elapsed <b>milliseconds</b>.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a5219a534cc2f71375f1bba76e3819695">setCancelTickWaitReqCb</a>(</div>
<div class="line">    []() -&gt; <span class="keywordtype">unsigned</span></div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// cancel timer</span></div>
<div class="line">        <span class="keywordflow">return</span> ...; <span class="comment">// return number of elapsed milliseconds</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a5219a534cc2f71375f1bba76e3819695"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a5219a534cc2f71375f1bba76e3819695">cc_mqttsn_gateway::Session::setCancelTickWaitReqCb</a></div><div class="ttdeci">void setCancelTickWaitReqCb(CancelTickWaitReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when previously requested time measurement needs to be cancelled.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> my_cancel_timer_req(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> session)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* cancel timer */</span></div>
<div class="line">    <span class="keywordflow">return</span> ...; <span class="comment">/* return number of elapsed milliseconds */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a9d8d8ef98f2182880f4b1868602026c0">cc_mqttsn_gw_session_set_cancel_tick_cb</a>(handle, &amp;my_cancel_timer_req, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a9d8d8ef98f2182880f4b1868602026c0"><div class="ttname"><a href="gateway__all_8h.html#a9d8d8ef98f2182880f4b1868602026c0">cc_mqttsn_gw_session_set_cancel_tick_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_cancel_tick_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionCancelTickReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when previously requested time measurement needs to be cancelled.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_term"></a>
Session Termination</h1>
<p>The <b>Session</b> object may recognise disconnection of MQTT-SN client and/or MQTT broker. As the result the session object must be destructed immediately and new one is created once the client renews its connection. The request to terminate the session is performed via callback, which must be set by the driving code.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a7325fc0c10dc1cae59a6ff9a2252e7ee">setTerminationReqCb</a>(</div>
<div class="line">    []()</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// Destruct session object.</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a7325fc0c10dc1cae59a6ff9a2252e7ee"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a7325fc0c10dc1cae59a6ff9a2252e7ee">cc_mqttsn_gateway::Session::setTerminationReqCb</a></div><div class="ttdeci">void setTerminationReqCb(TerminationReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when the session needs to be terminated and this Session object delete...</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_session_term(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> session)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* Remove reference to session object from internal data structures */</span></div>
<div class="line">    <a class="code hl_function" href="gateway__all_8h.html#a988a27a795d74e569fe9be3dd93fbf2a">cc_mqttsn_gw_session_free</a>(handle);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a89e01f95470aefe80752c495d7b45268">cc_mqttsn_gw_session_set_term_req_cb</a>(handle, &amp;my_session_term, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a89e01f95470aefe80752c495d7b45268"><div class="ttname"><a href="gateway__all_8h.html#a89e01f95470aefe80752c495d7b45268">cc_mqttsn_gw_session_set_term_req_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_term_req_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionTermReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when the Session needs to be terminated and the calling Session object...</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_broker_reconnect"></a>
Re-Connection to Broker</h1>
<p>The <b>MQTT-SN</b> protocol specification defines messages and operations, that are not properly supported by the <b>MQTT</b> protocol, such as will information update. The <b>Session</b> object supports these kind of operations by sending updated <b>CONNECT</b> request to the broker on behalf of the client. However, MQTT protocol disallows multiple <b>CONNECT</b> messages in the single connection session. As the result the gateway must perform the following steps:</p>
<ol type="1">
<li>send <b>DISCONNECT</b> message</li>
<li>close existing TCP/IP connection</li>
<li>open new TCP/IP connection</li>
<li>send new <b>CONNECT</b> message with updated connection information.</li>
</ol>
<p>Due to the reason, that TCP/IP connection to the broker is managed by the driving code, it must implement steps 2 and 3 in the list above.</p>
<p>The <b>Session</b> object issues the reconnection request via callback, which must be provided by the driving code.</p>
<p><b>C++</b> interface </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a2db095effa29cff1497342e4e0d638ac">setBrokerReconnectReqCb</a>(</div>
<div class="line">    []()</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// Close existing TCP/IP connection to broker and open a new one</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a2db095effa29cff1497342e4e0d638ac"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a2db095effa29cff1497342e4e0d638ac">cc_mqttsn_gateway::Session::setBrokerReconnectReqCb</a></div><div class="ttdeci">void setBrokerReconnectReqCb(BrokerReconnectReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when the session needs to close existing TCP/IP connection to the brok...</div></div>
</div><!-- fragment --><p><b>C</b> interface </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_broker_reconnect(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> session)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* Close existing TCP/IP connection to broker and open a new one */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a14fb2c660c6f321f061e99c66b343721">cc_mqttsn_gw_session_set_broker_reconnect_req_cb</a>(handle, &amp;my_broker_reconnect, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a14fb2c660c6f321f061e99c66b343721"><div class="ttname"><a href="gateway__all_8h.html#a14fb2c660c6f321f061e99c66b343721">cc_mqttsn_gw_session_set_broker_reconnect_req_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_broker_reconnect_req_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionBrokerReconnectReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when the Session needs to close existing TCP/IP connection to the brok...</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that the updated connection statuses of the broker (first disconnected and then connected) must be reported to the <b>Session</b> object when they happen. Details are in <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_broker_conn">Connection to Broker</a> section below.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_id"></a>
Gateway ID</h1>
<p>The MQTT-SN client may broadcast <b>SEARCHGW</b> message in an attempt to discover existing gateways on the network. The <b>Session</b> object is responsible to send <b>GWINFO</b> message as a response. Such message contains numeric gateway ID. Hence, the <b>Session</b> object must also be aware of the gateway ID information:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a6120e5c84cfa3e7a577c28ce5351cd2f">setGatewayId</a>(5);</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a6120e5c84cfa3e7a577c28ce5351cd2f"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a6120e5c84cfa3e7a577c28ce5351cd2f">cc_mqttsn_gateway::Session::setGatewayId</a></div><div class="ttdeci">void setGatewayId(std::uint8_t value)</div><div class="ttdoc">Set gateway numeric ID to be reported when requested.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#ab43525af01f83192fd7cb0c6297d3da3">cc_mqttsn_gw_session_set_id</a>(handle, 5);</div>
<div class="ttc" id="agateway__all_8h_html_ab43525af01f83192fd7cb0c6297d3da3"><div class="ttname"><a href="gateway__all_8h.html#ab43525af01f83192fd7cb0c6297d3da3">cc_mqttsn_gw_session_set_id</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_id(CC_MqttsnSessionHandle session, unsigned char id)</div><div class="ttdoc">Set gateway numeric ID to be reported when requested.</div></div>
</div><!-- fragment --><p>It is also possible to retrieve the current configuration:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">std::uint8_t <span class="keywordtype">id</span> = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a851aeead4cbdc80dedcc7d90ff13b517">getGatewayId</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a851aeead4cbdc80dedcc7d90ff13b517"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a851aeead4cbdc80dedcc7d90ff13b517">cc_mqttsn_gateway::Session::getGatewayId</a></div><div class="ttdeci">std::uint8_t getGatewayId() const</div><div class="ttdoc">Get configured gateway numeric ID to be reported when requested.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <span class="keywordtype">id</span> = <a class="code hl_function" href="gateway__all_8h.html#a47c783c426d93bda47e488cd108b32e1">cc_mqttsn_gw_session_get_id</a>(gw);</div>
<div class="ttc" id="agateway__all_8h_html_a47c783c426d93bda47e488cd108b32e1"><div class="ttname"><a href="gateway__all_8h.html#a47c783c426d93bda47e488cd108b32e1">cc_mqttsn_gw_session_get_id</a></div><div class="ttdeci">unsigned char cc_mqttsn_gw_session_get_id(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Get current gateway numeric ID configuration.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_retry"></a>
Retry Attempts</h1>
<p>There are cases when the communication to either client or broker is driven by the <b>Session</b> object itself. Such communication may involve messages that require acknowledgement by the other side. If acknowledgement is not received in time, the message must be re-sent. The <b>Session</b> object may be configured with duration (in <b>seconds</b>) between resend attempts and total number of attempts to perform.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a4159f98133b10a30982ee6c54e7c9be6">setRetryPeriod</a>(5U); <span class="comment">// 5 seconds between resend attempts</span></div>
<div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a65eea77d5c98b46c5ac12053976b0771">setRetryCount</a>(4U); <span class="comment">// up to 4 attempts to resend the same message</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a4159f98133b10a30982ee6c54e7c9be6"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a4159f98133b10a30982ee6c54e7c9be6">cc_mqttsn_gateway::Session::setRetryPeriod</a></div><div class="ttdeci">void setRetryPeriod(unsigned value)</div><div class="ttdoc">Set retry period to wait between resending unacknowledged message to the client and/or broker.</div></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a65eea77d5c98b46c5ac12053976b0771"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a65eea77d5c98b46c5ac12053976b0771">cc_mqttsn_gateway::Session::setRetryCount</a></div><div class="ttdeci">void setRetryCount(unsigned value)</div><div class="ttdoc">Set number of retry attempts to perform before abandoning attempt to send unacknowledged message.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#abd9a851d685fcac285aa3806d1865161">cc_mqttsn_gw_session_set_retry_period</a>(handle, 5U); <span class="comment">/* 5 seconds between resend attempts */</span></div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a46ae3079aeeefb1a07c688286543d62c">cc_mqttsn_gw_session_set_retry_count</a>(handle, 4U); <span class="comment">/* up to 4 attempts to resend the same message */</span></div>
<div class="ttc" id="agateway__all_8h_html_a46ae3079aeeefb1a07c688286543d62c"><div class="ttname"><a href="gateway__all_8h.html#a46ae3079aeeefb1a07c688286543d62c">cc_mqttsn_gw_session_set_retry_count</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_retry_count(CC_MqttsnSessionHandle session, unsigned value)</div><div class="ttdoc">Set number of retry attempts to perform before abandoning attempt to send unacknowledged message.</div></div>
<div class="ttc" id="agateway__all_8h_html_abd9a851d685fcac285aa3806d1865161"><div class="ttname"><a href="gateway__all_8h.html#abd9a851d685fcac285aa3806d1865161">cc_mqttsn_gw_session_set_retry_period</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_retry_period(CC_MqttsnSessionHandle session, unsigned value)</div><div class="ttdoc">Set retry period to wait between resending unacknowledged message to the client and/or broker.</div></div>
</div><!-- fragment --><p> If not configured, the default values of <b>10</b> seconds and <b>3</b> attempts apply.</p>
<p>It is also possible to retrieve the current configuration:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> retryPeriod = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a33f45dbe488afe79d8e06f430440a578">getRetryPeriod</a>();</div>
<div class="line"><span class="keywordtype">unsigned</span> retryCount = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#aed998167b253db7a980f88d124f3fbc7">getRetryCount</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a33f45dbe488afe79d8e06f430440a578"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a33f45dbe488afe79d8e06f430440a578">cc_mqttsn_gateway::Session::getRetryPeriod</a></div><div class="ttdeci">unsigned getRetryPeriod() const</div><div class="ttdoc">Get the current configuration of the retry period.</div></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_aed998167b253db7a980f88d124f3fbc7"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#aed998167b253db7a980f88d124f3fbc7">cc_mqttsn_gateway::Session::getRetryCount</a></div><div class="ttdeci">unsigned getRetryCount() const</div><div class="ttdoc">Get the current configuration of the retry count.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> retryPeriod = <a class="code hl_function" href="gateway__all_8h.html#aa2e77ceea4b2beff035f8787a9a37e3d">cc_mqttsn_gw_session_get_retry_period</a>(gw);</div>
<div class="line"><span class="keywordtype">unsigned</span> retryCount = <a class="code hl_function" href="gateway__all_8h.html#ad77b6399c0bfdbff462020afa05a3728">cc_mqttsn_gw_session_get_retry_count</a>(gw);</div>
<div class="ttc" id="agateway__all_8h_html_aa2e77ceea4b2beff035f8787a9a37e3d"><div class="ttname"><a href="gateway__all_8h.html#aa2e77ceea4b2beff035f8787a9a37e3d">cc_mqttsn_gw_session_get_retry_period</a></div><div class="ttdeci">unsigned cc_mqttsn_gw_session_get_retry_period(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Get the current configuration of the retry period.</div></div>
<div class="ttc" id="agateway__all_8h_html_ad77b6399c0bfdbff462020afa05a3728"><div class="ttname"><a href="gateway__all_8h.html#ad77b6399c0bfdbff462020afa05a3728">cc_mqttsn_gw_session_get_retry_count</a></div><div class="ttdeci">unsigned cc_mqttsn_gw_session_get_retry_count(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Get the current configuration of the retry count.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_predefined_topics"></a>
Predefined Topics</h1>
<p>The messages in MQTT-SN protocol are published with numeric topic IDs instead of strings (like in original MQTT). The protocol also allows bypassing the topic strings registration and using predefined IDs directly. In this case the <b>Session</b> object must be configured with all known and applicable topic string and topic numeric ID pairs. It will use this information to convert between numeric topic ID topic topic string when forwarding <b>PUBLISH</b> messages to both directions.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a507b38d797b9e4d302ce4e9eb8acdee5">addPredefinedTopic</a>(<span class="stringliteral">&quot;some/predefined/topic&quot;</span>, 123)) {</div>
<div class="line">    ... <span class="comment">// report error</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a507b38d797b9e4d302ce4e9eb8acdee5">addPredefinedTopic</a>(<span class="stringliteral">&quot;other/predefined/topic&quot;</span>, 1111)) {</div>
<div class="line">    ... <span class="comment">// report error</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a507b38d797b9e4d302ce4e9eb8acdee5"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a507b38d797b9e4d302ce4e9eb8acdee5">cc_mqttsn_gateway::Session::addPredefinedTopic</a></div><div class="ttdeci">bool addPredefinedTopic(const std::string &amp;topic, std::uint16_t topicId)</div><div class="ttdoc">Add predefined topic string and ID information.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="gateway__all_8h.html#a065cabe188acc70ffc769372d41d8acc">cc_mqttsn_gw_session_add_predefined_topic</a>(handle, <span class="stringliteral">&quot;some/predefined/topic&quot;</span>, 123)) {</div>
<div class="line">    ... <span class="comment">/* report error */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="gateway__all_8h.html#a065cabe188acc70ffc769372d41d8acc">cc_mqttsn_gw_session_add_predefined_topic</a>(handle, <span class="stringliteral">&quot;other/predefined/topic&quot;</span>, 1111)) {</div>
<div class="line">    ... <span class="comment">/* report error */</span></div>
<div class="line">}</div>
<div class="ttc" id="agateway__all_8h_html_a065cabe188acc70ffc769372d41d8acc"><div class="ttname"><a href="gateway__all_8h.html#a065cabe188acc70ffc769372d41d8acc">cc_mqttsn_gw_session_add_predefined_topic</a></div><div class="ttdeci">bool cc_mqttsn_gw_session_add_predefined_topic(CC_MqttsnSessionHandle session, const char *topic, unsigned short topicId)</div><div class="ttdoc">Add predefined topic string and ID information.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_topics_registration"></a>
Allocating Topic IDs</h1>
<p>When not using predefined topic IDs, there is a process of topic string registration and allocating relevant numeric topic ID. This allocation is performed by the <b>Session</b> object. By default the <b>Session</b> object will pick the first number available. However, it may be wise to reserve some range of topic IDs to be predefined ones, especially when there are some <b>client</b> <b>specific</b> predefined topic IDs, which added later when connected client ID is known (see <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_connected_client">Connected Client Report</a>). The library provides a way to limit range of topic IDs allocated during the registration process.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#adfe4fadd74fdf75b997f10604093d91e">setTopicIdAllocationRange</a>(0x1000, 0xffff)) {</div>
<div class="line">    ... <span class="comment">// report error</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_adfe4fadd74fdf75b997f10604093d91e"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#adfe4fadd74fdf75b997f10604093d91e">cc_mqttsn_gateway::Session::setTopicIdAllocationRange</a></div><div class="ttdeci">bool setTopicIdAllocationRange(std::uint16_t minVal, std::uint16_t maxVal)</div><div class="ttdoc">Limit range of topic IDs allocated for newly registered topics.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="gateway__all_8h.html#afab11f43de8774d1f460fc2488e3fa4b">cc_mqttsn_gw_session_set_topic_id_alloc_range</a>(handle, 0x1000, 0xffff)) {</div>
<div class="line">    ... <span class="comment">// report error</span></div>
<div class="line">}</div>
<div class="ttc" id="agateway__all_8h_html_afab11f43de8774d1f460fc2488e3fa4b"><div class="ttname"><a href="gateway__all_8h.html#afab11f43de8774d1f460fc2488e3fa4b">cc_mqttsn_gw_session_set_topic_id_alloc_range</a></div><div class="ttdeci">bool cc_mqttsn_gw_session_set_topic_id_alloc_range(CC_MqttsnSessionHandle session, unsigned short minTopicId, unsigned short maxTopicId)</div><div class="ttdoc">Limit range of topic IDs allocated for newly registered topics.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_start"></a>
Start Operation</h1>
<p>After been properly configured the <b>Session</b> object needs to be started.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a12513af6a5f2db6ebc57947771379bca">start</a>()) {</div>
<div class="line">    ... <span class="comment">// The session hasn&#39;t been properly configured, report error</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a12513af6a5f2db6ebc57947771379bca"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a12513af6a5f2db6ebc57947771379bca">cc_mqttsn_gateway::Session::start</a></div><div class="ttdeci">bool start()</div><div class="ttdoc">Start this object's operation.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="gateway__all_8h.html#a338c5ca1a6a15590ca59c4e1d909e157">cc_mqttsn_gw_session_start</a>(handle)) {</div>
<div class="line">    ... <span class="comment">/* The session hasn&#39;t been properly configured, report error */</span></div>
<div class="line">}</div>
<div class="ttc" id="agateway__all_8h_html_a338c5ca1a6a15590ca59c4e1d909e157"><div class="ttname"><a href="gateway__all_8h.html#a338c5ca1a6a15590ca59c4e1d909e157">cc_mqttsn_gw_session_start</a></div><div class="ttdeci">bool cc_mqttsn_gw_session_start(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Start the Session's object's operation.</div></div>
</div><!-- fragment --><p> If not properly started, the <b>Session</b> object will ignore any input from client and broker.</p>
<p>The operation of the <b>Session</b> object can also be stopped / paused for a while.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#ae4a65f7acc2a8af7170daccc35278de5">stop</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ae4a65f7acc2a8af7170daccc35278de5"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ae4a65f7acc2a8af7170daccc35278de5">cc_mqttsn_gateway::Session::stop</a></div><div class="ttdeci">void stop()</div><div class="ttdoc">Stop the operation of the object.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#ab986ac42e699650ca4a772574c2a0438">cc_mqttsn_gw_session_stop</a>(handle);</div>
<div class="ttc" id="agateway__all_8h_html_ab986ac42e699650ca4a772574c2a0438"><div class="ttname"><a href="gateway__all_8h.html#ab986ac42e699650ca4a772574c2a0438">cc_mqttsn_gw_session_stop</a></div><div class="ttdeci">void cc_mqttsn_gw_session_stop(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Stop the operation of the Session object.</div></div>
</div><!-- fragment --><p> The operation of the stopped <b>Session</b> object may be restarted using the same <a class="el" href="classcc__mqttsn__gateway_1_1Session.html#a12513af6a5f2db6ebc57947771379bca" title="Start this object&#39;s operation.">cc_mqttsn_gateway::Session::start()</a> and <a class="el" href="gateway__all_8h.html#a338c5ca1a6a15590ca59c4e1d909e157" title="Start the Session&#39;s object&#39;s operation.">cc_mqttsn_gw_session_start()</a> functions.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_broker_conn"></a>
Connection to Broker</h1>
<p><b>AFTER</b> (important emphasis here) successfully starting operation of the <b>Session</b> object (see <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_start">Start Operation</a>) the driving code must initiate TCP/IP connection to the MQTT broker. The driving code must also constantly monitor the state of this connection and to the <b>Session</b> object any detected change. When started, the <b>Session</b> object assumes broker is <b>disconnected</b>.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#ab3ce2cc8b3a964625a6b59c70ceb8a9c">setBrokerConnected</a>(<span class="keyword">true</span>); <span class="comment">// Reports broker being connected</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ab3ce2cc8b3a964625a6b59c70ceb8a9c"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ab3ce2cc8b3a964625a6b59c70ceb8a9c">cc_mqttsn_gateway::Session::setBrokerConnected</a></div><div class="ttdeci">void setBrokerConnected(bool connected)</div><div class="ttdoc">Notify the Session object about broker being connected / disconnected.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#ad91cf390da725478e498f1b5db319fcb">cc_mqttsn_gw_session_set_broker_connected</a>(handle, <span class="keyword">true</span>); <span class="comment">// Reports broker being connected</span></div>
<div class="ttc" id="agateway__all_8h_html_ad91cf390da725478e498f1b5db319fcb"><div class="ttname"><a href="gateway__all_8h.html#ad91cf390da725478e498f1b5db319fcb">cc_mqttsn_gw_session_set_broker_connected</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_broker_connected(CC_MqttsnSessionHandle session, bool connected)</div><div class="ttdoc">Notify the Session object about broker being connected / disconnected.</div></div>
</div><!-- fragment --><p> When issuing broker re-connection request (see <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_broker_reconnect">Re-Connection to Broker</a>), the <b>Session</b> object expects this call to happen twice: the first one for disconnection report and second one for new connection report.</p>
<p>The driving code also responsible to detect unsolicited disconnects of TCP/IP link to the broker and report it to the <b>Session</b> object using the same function call.</p>
<p>It is also possible to retrieve the current status:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> brokerConnected = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a1c37fd734a015d27bdb2360d7e311fe8">getBrokerConnected</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a1c37fd734a015d27bdb2360d7e311fe8"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a1c37fd734a015d27bdb2360d7e311fe8">cc_mqttsn_gateway::Session::getBrokerConnected</a></div><div class="ttdeci">bool getBrokerConnected() const</div><div class="ttdoc">Get currently recorded broker connection status.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> brokerConnected = <a class="code hl_function" href="gateway__all_8h.html#a20e9c0966372dc809f8db6d8689cb3ea">cc_mqttsn_gw_session_get_broker_connected</a>(handle);</div>
<div class="ttc" id="agateway__all_8h_html_a20e9c0966372dc809f8db6d8689cb3ea"><div class="ttname"><a href="gateway__all_8h.html#a20e9c0966372dc809f8db6d8689cb3ea">cc_mqttsn_gw_session_get_broker_connected</a></div><div class="ttdeci">bool cc_mqttsn_gw_session_get_broker_connected(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Get currently recorded broker connection status.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_client_auth"></a>
Client Authentication</h1>
<p>The <b>MQTT</b> protocol supports client authentication, where the <b>CONNECT</b> message may contain username and password. The <b>MQTT-SN</b> protocol, on the other hand, lacks this feature. The <b>Session</b> object provides an ability to set a callback function, which will be invoked when MQTT-SN client's connection request is recognised. This callback may provide authentication information for this client, which is going to be filled in the forwarded <b>CONNECT</b> request.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#ab519faa29c6d2386e2b305fdb2289bbf">setAuthInfoReqCb</a>(</div>
<div class="line">    [](<span class="keyword">const</span> std::string&amp; clientId) -&gt; <a class="code hl_typedef" href="classcc__mqttsn__gateway_1_1Session.html#a18ce4af1ec9bd9368cdbe082537cac6e">cc_mqttsn_gateway::Session::AuthInfo</a></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(getUsernameFor(clientId), getPasswordFor(clientId));</div>
<div class="line">        </div>
<div class="line">    }); </div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a18ce4af1ec9bd9368cdbe082537cac6e"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a18ce4af1ec9bd9368cdbe082537cac6e">cc_mqttsn_gateway::Session::AuthInfo</a></div><div class="ttdeci">std::pair&lt; std::string, BinaryData &gt; AuthInfo</div><div class="ttdoc">Type of authentication information.</div><div class="ttdef"><b>Definition</b> Session.h:38</div></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ab519faa29c6d2386e2b305fdb2289bbf"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ab519faa29c6d2386e2b305fdb2289bbf">cc_mqttsn_gateway::Session::setAuthInfoReqCb</a></div><div class="ttdeci">void setAuthInfoReqCb(AuthInfoReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be used to request authentication information for specific client.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_auth_callback(</div>
<div class="line">    <span class="keywordtype">void</span>* userData, </div>
<div class="line">    <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> handle,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* clientId, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>** username, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** password, </div>
<div class="line">    <span class="keywordtype">unsigned</span>* passwordLen)</div>
<div class="line">{</div>
<div class="line">    *username = ...; <span class="comment">/* assign pointer to username for provided client ID */</span></div>
<div class="line">    *password = ...; <span class="comment">/* assign pointer to password for provided client ID */</span></div>
<div class="line">    *passwordLen = ...; <span class="comment">/* specify length of the password */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a6f97671aaae458452921533ee58868ad">cc_mqttsn_gw_session_set_auth_info_req_cb</a>(handle, &amp;my_auth_callback, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a6f97671aaae458452921533ee58868ad"><div class="ttname"><a href="gateway__all_8h.html#a6f97671aaae458452921533ee58868ad">cc_mqttsn_gw_session_set_auth_info_req_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_auth_info_req_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionAuthInfoReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be used to request authentication information for specific client.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_connected_client"></a>
Connected Client Report</h1>
<p>The <b>Session</b> object provides an ability to get notified when a MQTT-SN client is successfully connected. The notification is performed using a callback. Inside this callback, the driving code may provide some client specific configurations, such as new predefined topic IDs relevant only to the connected client.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#aa78b22f6b7144f598639160703376292">setClientConnectedReportCb</a>(</div>
<div class="line">    [session](<span class="keyword">const</span> std::string&amp; clientId)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a507b38d797b9e4d302ce4e9eb8acdee5">addPredefinedTopic</a>(<span class="stringliteral">&quot;client/specific/predefined/topic&quot;</span>, 2222)) {</div>
<div class="line">            ... <span class="comment">/* report error */</span></div>
<div class="line">        }</div>
<div class="line">    }); </div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_aa78b22f6b7144f598639160703376292"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#aa78b22f6b7144f598639160703376292">cc_mqttsn_gateway::Session::setClientConnectedReportCb</a></div><div class="ttdeci">void setClientConnectedReportCb(ClientConnectedReportCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when MQTT-SN client is successfully connected to the broker.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_client_connect_report(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> handle, <span class="keyword">const</span> <span class="keywordtype">char</span>* clientId)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_function" href="gateway__all_8h.html#a065cabe188acc70ffc769372d41d8acc">cc_mqttsn_gw_session_add_predefined_topic</a>(handle, <span class="stringliteral">&quot;client/specific/predefined/topic&quot;</span>, 2222)) {</div>
<div class="line">        ... <span class="comment">/* report error */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#ad534980071149dcd84e31174bc4f36ab">cc_mqttsn_gw_session_set_client_connect_report_cb</a>(handle, &amp;my_client_connect_report, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_ad534980071149dcd84e31174bc4f36ab"><div class="ttname"><a href="gateway__all_8h.html#ad534980071149dcd84e31174bc4f36ab">cc_mqttsn_gw_session_set_client_connect_report_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_client_connect_report_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionClientConnectReportCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when MQTT-SN client is successfully connected to the broker.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_default_client_id"></a>
Default Client ID</h1>
<p>The <b>Session</b> object interface allows to specify the default ID of the client, which is going to be used to connect to broker, if the client doesn't provide non-empty ID string in its connection attempt. This may be useful when client is connected over one-to-one I/O link such as <b>RS-232</b>. In order to simplify the client implementation and reduce amount of data transferred on the link, the <b>Session</b> object may be configured to substitute the empty client ID with other, non-empty one, when forwarding the connection request to the broker.</p>
<p>The default client ID configuration may also be used with "publish
only" clients (see <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_publish_only">Publish Only Client</a> below). The configured client ID will be used when connecting to the broker on behalf of the "publish only" client.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a31a9ce1bc29973c0659044f752ff3d14">setDefaultClientId</a>(<span class="stringliteral">&quot;some_default_id&quot;</span>);</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a31a9ce1bc29973c0659044f752ff3d14"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a31a9ce1bc29973c0659044f752ff3d14">cc_mqttsn_gateway::Session::setDefaultClientId</a></div><div class="ttdeci">void setDefaultClientId(const std::string &amp;value)</div><div class="ttdoc">Provide default client ID for clients that report empty one in their attempt to connect.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#ae3bc2ab5acee7ee27bc17aa0cf98ab7f">cc_mqttsn_gw_session_set_default_client_id</a>(handle, <span class="stringliteral">&quot;some_default_id&quot;</span>);</div>
<div class="ttc" id="agateway__all_8h_html_ae3bc2ab5acee7ee27bc17aa0cf98ab7f"><div class="ttname"><a href="gateway__all_8h.html#ae3bc2ab5acee7ee27bc17aa0cf98ab7f">cc_mqttsn_gw_session_set_default_client_id</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_default_client_id(CC_MqttsnSessionHandle session, const char *clientId)</div><div class="ttdoc">Provide default client ID for clients that report empty one in their attempt to connect.</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that the <b>Session</b> object will make an attempt to substitute reported client ID <b>if and only if</b> the client ID <b>is</b> empty and configured default client ID is <b>NOT</b>.</p>
<p>It is also possible to retrieve the current configuration:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keyword">const</span> std::string&amp; defaultClientId = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a361a7c0c1871010437ac0877eba43242">getDefaultClientId</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a361a7c0c1871010437ac0877eba43242"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a361a7c0c1871010437ac0877eba43242">cc_mqttsn_gateway::Session::getDefaultClientId</a></div><div class="ttdeci">const std::string &amp; getDefaultClientId() const</div><div class="ttdoc">Get current default client id configuration.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* defaultClientId = <a class="code hl_function" href="gateway__all_8h.html#a14cb86dfe5a00fb6a1302b33dd1ce142">cc_mqttsn_gw_session_get_default_client_id</a>(handle);</div>
<div class="ttc" id="agateway__all_8h_html_a14cb86dfe5a00fb6a1302b33dd1ce142"><div class="ttname"><a href="gateway__all_8h.html#a14cb86dfe5a00fb6a1302b33dd1ce142">cc_mqttsn_gw_session_get_default_client_id</a></div><div class="ttdeci">const char * cc_mqttsn_gw_session_get_default_client_id(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Get current default client ID configuration.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_publish_only"></a>
Publish Only Client</h1>
<p>The MQTT-SN protocol allows "publish only" clients, which don't make an attempt to connect to the gateway/broker, but allowed to publish messages with predefined topic IDs and QoS=-1. The gateway must connect to the broker on behalf of such client. The connection operation involves knowledge about client ID and "keep alive" period. The client ID, that is going to be used, is configured as <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_default_client_id">Default Client ID</a>. The "keep alive" period can be provided using separate function:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#ad9933a5769200858d7faa2bf1f374d82">setPubOnlyKeepAlive</a>(100); <span class="comment">// 100 seconds</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ad9933a5769200858d7faa2bf1f374d82"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ad9933a5769200858d7faa2bf1f374d82">cc_mqttsn_gateway::Session::setPubOnlyKeepAlive</a></div><div class="ttdeci">void setPubOnlyKeepAlive(std::uint16_t value)</div><div class="ttdoc">Provide default &quot;keep alive&quot; period for &quot;publish only&quot; clients, that do not make an attempt to connec...</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#a4ec46b242b81d482ca6b71b15a0ecfc8">cc_mqttsn_gw_session_set_pub_only_keep_alive</a>(handle, 100); <span class="comment">/* 100 seconds */</span></div>
<div class="ttc" id="agateway__all_8h_html_a4ec46b242b81d482ca6b71b15a0ecfc8"><div class="ttname"><a href="gateway__all_8h.html#a4ec46b242b81d482ca6b71b15a0ecfc8">cc_mqttsn_gw_session_set_pub_only_keep_alive</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_pub_only_keep_alive(CC_MqttsnSessionHandle session, unsigned value)</div><div class="ttdoc">Provide default &quot;keep alive&quot; period for &quot;publish only&quot; clients, that do not make an attempt to connec...</div></div>
</div><!-- fragment --><p> If such configuration is not provided, the default value of <b>60</b> seconds is assumed.</p>
<p>It is also possible to retrieve the current configuration:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">std::uint16_t pubOnlyKeepAlive = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a4f4c3c29fb9238733200686d039552da">getPubOnlyKeepAlive</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a4f4c3c29fb9238733200686d039552da"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a4f4c3c29fb9238733200686d039552da">cc_mqttsn_gateway::Session::getPubOnlyKeepAlive</a></div><div class="ttdeci">std::uint16_t getPubOnlyKeepAlive() const</div><div class="ttdoc">Get current configuration of the default &quot;keep alive&quot; period for &quot;publish only&quot; clients.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> pubOnlyKeepAlive = <a class="code hl_function" href="gateway__all_8h.html#add5e69dcad73beb03118f7da60046cdc">cc_mqttsn_gw_session_get_pub_only_keep_alive</a>(handle);</div>
<div class="ttc" id="agateway__all_8h_html_add5e69dcad73beb03118f7da60046cdc"><div class="ttname"><a href="gateway__all_8h.html#add5e69dcad73beb03118f7da60046cdc">cc_mqttsn_gw_session_get_pub_only_keep_alive</a></div><div class="ttdeci">unsigned cc_mqttsn_gw_session_get_pub_only_keep_alive(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Get current configuration of the default &quot;keep alive&quot; period for &quot;publish only&quot; clients.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_sleep"></a>
Sleeping Client</h1>
<p>The <b>Session</b> object supports client entering the <b>SLEEP</b> mode without any extra configuration. It will send the <b>PINGREQ</b> messages on behalf of the client to keep the connection to the broker alive, and will accumulate all the messages sent to the client until it wakes up.</p>
<p>However, it may be a good idea to limit the number of messages, the <b>Session</b> object is allowed to accumulate, to avoid consumption of too much memory.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a0b96e11b66b6ece04f8a331c9b72600c">setSleepingClientMsgLimit</a>(1000); <span class="comment">// no more that 1000 messages</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a0b96e11b66b6ece04f8a331c9b72600c"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a0b96e11b66b6ece04f8a331c9b72600c">cc_mqttsn_gateway::Session::setSleepingClientMsgLimit</a></div><div class="ttdeci">void setSleepingClientMsgLimit(std::size_t value)</div><div class="ttdoc">Provide limit to number pending messages being accumulated for the sleeping client.</div></div>
</div><!-- fragment --><p><b>C++</b> interface: </p><div class="fragment"><div class="line"><a class="code hl_function" href="gateway__all_8h.html#abfe81acfdb4d7895bc81bb0de4fc8c6d">cc_mqttsn_gw_session_set_sleeping_client_msg_limit</a>(handle, 1000); <span class="comment">/* no more that 1000 messages */</span></div>
<div class="ttc" id="agateway__all_8h_html_abfe81acfdb4d7895bc81bb0de4fc8c6d"><div class="ttname"><a href="gateway__all_8h.html#abfe81acfdb4d7895bc81bb0de4fc8c6d">cc_mqttsn_gw_session_set_sleeping_client_msg_limit</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_sleeping_client_msg_limit(CC_MqttsnSessionHandle session, unsigned long long value)</div><div class="ttdoc">Provide limit to number pending messages being accumulated for the sleeping client.</div></div>
</div><!-- fragment --><p>It is also possible to retrieve the current configuration:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">std::size_t limit = session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a0160ae049acb4d1d60feed15bc09b921">getSleepingClientMsgLimit</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a0160ae049acb4d1d60feed15bc09b921"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a0160ae049acb4d1d60feed15bc09b921">cc_mqttsn_gateway::Session::getSleepingClientMsgLimit</a></div><div class="ttdeci">std::size_t getSleepingClientMsgLimit() const</div><div class="ttdoc">Get currenly configured limit to pending messages being accumulated for the sleeping client.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> limit = <a class="code hl_function" href="gateway__all_8h.html#a1729da897d177ac7a8599f9e2b7cd246">cc_mqttsn_gw_session_get_sleeping_client_msg_limit</a>(handle);</div>
<div class="ttc" id="agateway__all_8h_html_a1729da897d177ac7a8599f9e2b7cd246"><div class="ttname"><a href="gateway__all_8h.html#a1729da897d177ac7a8599f9e2b7cd246">cc_mqttsn_gw_session_get_sleeping_client_msg_limit</a></div><div class="ttdeci">unsigned long long cc_mqttsn_gw_session_get_sleeping_client_msg_limit(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Get currenly configured limit to pending messages being accumulated for the sleeping client.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_fwd_enc"></a>
Forwarder Encapsulation Support</h1>
<p>In case the gateway need to support forwarder encapsulation functionality there is a need to set extra two callbacks.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#aca05f624d53ec51fb6b2db201b2dfd19">setFwdEncSessionCreatedReportCb</a>(</div>
<div class="line">    [](<a class="code hl_class" href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a>* fwdSession) -&gt; <span class="keywordtype">bool</span></div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// Perform the session configuration and set all the necessary callbacks</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a748fdd26e5639d274e4f28d2f3c2fe56">setFwdEncSessionDeletedReportCb</a>(</div>
<div class="line">    [](<a class="code hl_class" href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a>* fwdSession) -&gt; <span class="keywordtype">bool</span></div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// Remove any reference to fwdSession in the data structures</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a748fdd26e5639d274e4f28d2f3c2fe56"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a748fdd26e5639d274e4f28d2f3c2fe56">cc_mqttsn_gateway::Session::setFwdEncSessionDeletedReportCb</a></div><div class="ttdeci">void setFwdEncSessionDeletedReportCb(FwdEncSessionDeletedReportCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when the forwarding encapsulation session is about to be deleted.</div></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_aca05f624d53ec51fb6b2db201b2dfd19"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#aca05f624d53ec51fb6b2db201b2dfd19">cc_mqttsn_gateway::Session::setFwdEncSessionCreatedReportCb</a></div><div class="ttdeci">void setFwdEncSessionCreatedReportCb(FwdEncSessionCreatedReportCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when the forwarding encapsulation session is detected and to notify ap...</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> my_fwd_enc_session_created_report_cb(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> handle)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">// Perform the session configuration and set all the necessary callbacks</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_fwd_enc_session_deleted_report_cb(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> handle)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">// Remove any reference to handle in the data structures</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#ac415881691d329807c5492e9b81b84f4">cc_mqttsn_gw_session_set_fwd_enc_session_created_cb</a>(handle, &amp;my_fwd_enc_session_created_report_cb, someDserData);</div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a53ac516ddbbf1050452e9592bac45570">cc_mqttsn_gw_session_set_fwd_enc_session_deleted_cb</a>(handle, &amp;my_fwd_enc_session_deleted_report_cb, someDserData);</div>
<div class="ttc" id="agateway__all_8h_html_a53ac516ddbbf1050452e9592bac45570"><div class="ttname"><a href="gateway__all_8h.html#a53ac516ddbbf1050452e9592bac45570">cc_mqttsn_gw_session_set_fwd_enc_session_deleted_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_fwd_enc_session_deleted_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionFwdEncSessionDeletedCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when the forwarding encapsulation session is about to be deleted.</div></div>
<div class="ttc" id="agateway__all_8h_html_ac415881691d329807c5492e9b81b84f4"><div class="ttname"><a href="gateway__all_8h.html#ac415881691d329807c5492e9b81b84f4">cc_mqttsn_gw_session_set_fwd_enc_session_created_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_fwd_enc_session_created_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionFwdEncSessionCreatedCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when the forwarding encapsulation session is detected and to notify ap...</div></div>
</div><!-- fragment --><p>When the new forward encapsulation session creation is reported, the application is responsible to perform the necessary session configuration as well as set all the necessary callbacks, except the <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_send_client">Sending Data to Client</a> and the <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_term">Session Termination</a>. These callbacks will be set by the reporting session.</p>
<p>The reported forward encapsulation session object is owned by the reporting session and its deletion will be reported using the deletion report callback.</p>
<p>The gateway application is responsible to manage the connection to the broker as well as timers of the reported forward encapsulation session.</p>
<p>When the forward encapsulation session is reported, it's not <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_start">started</a> yet. It will be when the callback function returns. However, the gateway application is expected to initiate asynchronous connection to the broker and report the <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_broker_conn">connectivity</a> later on. The <b>important</b> part is that broker connectivity must be reported <b>after</b> the callback function returns.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_error_report"></a>
Errors Report</h1>
<p>The gateway library can detect and report some unexpected behavior from the application, client, and/or broker. The <b>Session</b> object reports such errors via callback:</p>
<p><b>C++</b> interface </p><div class="fragment"><div class="line">session-&gt;<a class="code hl_function" href="classcc__mqttsn__gateway_1_1Session.html#a63ad6bad2e911a882b42fda99a827c70">setErrorReportCb</a>(</div>
<div class="line">    [](<span class="keyword">const</span> <span class="keywordtype">char</span>* msg)</div>
<div class="line">    {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;ERROR: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a63ad6bad2e911a882b42fda99a827c70"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a63ad6bad2e911a882b42fda99a827c70">cc_mqttsn_gateway::Session::setErrorReportCb</a></div><div class="ttdeci">void setErrorReportCb(ErrorReportCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be used to report detected errors.</div></div>
</div><!-- fragment --><p><b>C</b> interface </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_error_report(<span class="keywordtype">void</span>* userData, <a class="code hl_typedef" href="gateway__all_8h.html#a1a903f928f9f0166dd06326da57aa0d0">CC_MqttsnSessionHandle</a> session, <span class="keyword">const</span> <span class="keywordtype">char</span>* msg)</div>
<div class="line">{</div>
<div class="line">    printf(<span class="stringliteral">&quot;ERROR: %s\n&quot;</span>, msg);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="gateway__all_8h.html#a010e04f3b13369cdd67f022f13cd0879">cc_mqttsn_gw_session_set_error_report_cb</a>(handle, &amp;my_error_report, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a010e04f3b13369cdd67f022f13cd0879"><div class="ttname"><a href="gateway__all_8h.html#a010e04f3b13369cdd67f022f13cd0879">cc_mqttsn_gw_session_set_error_report_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_error_report_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionErrorReportCb cb, void *data)</div><div class="ttdoc">Set the callback to be used to report error messages detected by the session.</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
