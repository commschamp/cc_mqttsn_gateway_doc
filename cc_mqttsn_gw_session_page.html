<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MQTT-SN Gateway Library: Session</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MQTT-SN Gateway Library
   </div>
   <div id="projectbrief">Library that allows implementation of MQTT-SN gateway.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Session </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#cc_mqttsn_gw_session_page_alloc">Allocation</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_recv">Receiving Data</a><ul><li class="level2"><a href="#cc_mqttsn_gw_session_page_recv_client">Receiving Data from Client</a></li>
<li class="level2"><a href="#cc_mqttsn_gw_session_page_recv_broker">Receiving Data from Broker</a></li>
</ul>
</li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_send">Sending Data</a><ul><li class="level2"><a href="#cc_mqttsn_gw_session_page_send_client">Sending Data to Client</a></li>
<li class="level2"><a href="#cc_mqttsn_gw_session_page_send_broker">Sending Data to Broker</a></li>
</ul>
</li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_time">Time Measurement</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_term">Session Termination</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_broker_reconnect">Re-Connection to Broker</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_id">Gateway ID</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_retry">Retry Attempts</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_predefined_topics">Predefined Topics</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_topics_registration">Allocating Topic IDs</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_start">Start Operation</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_broker_conn">Connection to Broker</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_client_auth">Client Authentication</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_connected_client">Connected Client Report</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_default_client_id">Default Client ID</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_publish_only">Publish Only Client</a></li>
<li class="level1"><a href="#cc_mqttsn_gw_session_page_sleep">Sleeping Client</a></li>
</ul>
</div>
<div class="textblock"><p>The <b>Session</b> object is responsible to manage and forward traffic of messages between <b>single</b> MQTT-SN client and the broker. When new message is received over the I/O link, the driving code must check whether any <b>Session</b> object has already been created for the client that sent the message (the clients can be differentiated by their origin address). If such <b>Session</b> does NOT exist, it must be created.</p>
<p>The received data needs to be forwarded to appropriate <b>Session</b> object for processing. And when the <b>Session</b> object requests to send message back, it needs to be sent to the right address. It is a responsibility of the driving code to maintain a valid map between the client's address and appropriate <b>Session</b> object.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_alloc"></a>
Allocation</h1>
<p>When using <b>C++</b> interface, just instantiate object of <a class="el" href="classcc__mqttsn__gateway_1_1Session.html" title="Interface for Session entity.">cc_mqttsn_gateway::Session</a> class. The destruction of the object will clean up all acquired resources. </p><div class="fragment"><div class="line"><a class="code" href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a>* session = <span class="keyword">new</span> <a class="code" href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a>(); <span class="comment">// make sure to use smart pointer in production code</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html">cc_mqttsn_gateway::Session</a></div><div class="ttdoc">Interface for Session entity.</div><div class="ttdef"><b>Definition:</b> Session.h:29</div></div>
</div><!-- fragment --><p>When using <b>C</b> interface, the allocation is performed using <a class="el" href="gateway__all_8h.html#a5c78e0c26c7400fa6508f6f51522f144" title="Allocate Session object.">cc_mqttsn_gw_session_alloc()</a> </p><div class="fragment"><div class="line"><a class="code" href="structCC__MqttsnSessionHandle.html">CC_MqttsnSessionHandle</a> handle = <a class="code" href="gateway__all_8h.html#a5c78e0c26c7400fa6508f6f51522f144">cc_mqttsn_gw_session_alloc</a>();</div>
<div class="ttc" id="agateway__all_8h_html_a5c78e0c26c7400fa6508f6f51522f144"><div class="ttname"><a href="gateway__all_8h.html#a5c78e0c26c7400fa6508f6f51522f144">cc_mqttsn_gw_session_alloc</a></div><div class="ttdeci">CC_MqttsnSessionHandle cc_mqttsn_gw_session_alloc(void)</div><div class="ttdoc">Allocate Session object.</div></div>
<div class="ttc" id="astructCC__MqttsnSessionHandle_html"><div class="ttname"><a href="structCC__MqttsnSessionHandle.html">CC_MqttsnSessionHandle</a></div><div class="ttdoc">Handle for session object used in all cc_mqttsn_gw_session_* functions.</div><div class="ttdef"><b>Definition:</b> gateway_all.h:130</div></div>
</div><!-- fragment --><p> and de-allocation is performed using <a class="el" href="gateway__all_8h.html#a988a27a795d74e569fe9be3dd93fbf2a" title="Free allocated Session object.">cc_mqttsn_gw_session_free()</a> functions. </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#a988a27a795d74e569fe9be3dd93fbf2a">cc_mqttsn_gw_session_free</a>(handle);</div>
<div class="ttc" id="agateway__all_8h_html_a988a27a795d74e569fe9be3dd93fbf2a"><div class="ttname"><a href="gateway__all_8h.html#a988a27a795d74e569fe9be3dd93fbf2a">cc_mqttsn_gw_session_free</a></div><div class="ttdeci">void cc_mqttsn_gw_session_free(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Free allocated Session object.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_recv"></a>
Receiving Data</h1>
<p>The MQTT-SN gateway <b>Session</b> serves as message translator and forwarder between MQTT-SN client and MQTT broker. The driver code is responsible to manage these two independent communication links. Once a message is received on any of them, it must be provided the the <b>Session</b> object for processing.</p>
<h2><a class="anchor" id="cc_mqttsn_gw_session_page_recv_client"></a>
Receiving Data from Client</h2>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">std::size_t consumed = session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a3ef4bfb2e5c6d6768ba1b9ef75e82f93">dataFromClient</a>(buf, bufLen);</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a3ef4bfb2e5c6d6768ba1b9ef75e82f93"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a3ef4bfb2e5c6d6768ba1b9ef75e82f93">cc_mqttsn_gateway::Session::dataFromClient</a></div><div class="ttdeci">std::size_t dataFromClient(const std::uint8_t *buf, std::size_t len)</div><div class="ttdoc">Provide data received from the client for processing.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> consumed = <a class="code" href="gateway__all_8h.html#a9cd75cfcd9fc320610c1747ece2aeb83">cc_mqttsn_gw_session_data_from_client</a>(handle, buf, bufLen);</div>
<div class="ttc" id="agateway__all_8h_html_a9cd75cfcd9fc320610c1747ece2aeb83"><div class="ttname"><a href="gateway__all_8h.html#a9cd75cfcd9fc320610c1747ece2aeb83">cc_mqttsn_gw_session_data_from_client</a></div><div class="ttdeci">unsigned cc_mqttsn_gw_session_data_from_client(CC_MqttsnSessionHandle session, const unsigned char *buf, unsigned bufLen)</div><div class="ttdoc">Provide data received from the client for processing.</div></div>
</div><!-- fragment --><p><b>NOTE</b>, that functions return number of bytes that were actually processed. If number of processed bytes is less that number of bytes residing in the buffer, then probably some unexpected protocol error has occurred.</p>
<p>The call to this function may cause invocation of various callback functions that have been set.</p>
<h2><a class="anchor" id="cc_mqttsn_gw_session_page_recv_broker"></a>
Receiving Data from Broker</h2>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">std::size_t consumed = session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a728ac52d1c104c446c5c4b059d16d9e1">dataFromBroker</a>(buf, bufLen);</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a728ac52d1c104c446c5c4b059d16d9e1"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a728ac52d1c104c446c5c4b059d16d9e1">cc_mqttsn_gateway::Session::dataFromBroker</a></div><div class="ttdeci">std::size_t dataFromBroker(const std::uint8_t *buf, std::size_t len)</div><div class="ttdoc">Provide data received from the broker for processing.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> consumed = <a class="code" href="gateway__all_8h.html#add5b16f698d0ff7af1add101f9386c56">cc_mqttsn_gw_session_data_from_broker</a>(handle, buf, bufLen);</div>
<div class="ttc" id="agateway__all_8h_html_add5b16f698d0ff7af1add101f9386c56"><div class="ttname"><a href="gateway__all_8h.html#add5b16f698d0ff7af1add101f9386c56">cc_mqttsn_gw_session_data_from_broker</a></div><div class="ttdeci">unsigned cc_mqttsn_gw_session_data_from_broker(CC_MqttsnSessionHandle session, const unsigned char *buf, unsigned bufLen)</div><div class="ttdoc">Provide data received from the broker for processing.</div></div>
</div><!-- fragment --><p><b>NOTE</b>, that functions return number of bytes that were actually processed. If number of processed bytes is less that number of bytes residing in the buffer, then probably some unexpected protocol error has occurred.</p>
<p>The call to this function may cause invocation of various callback functions that have been set.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_send"></a>
Sending Data</h1>
<p>The <b>Session</b> object may require to send a message to either client or broker. The driving code has to provide appropriate callbacks for this purpose. When the callback is invoked, it is provided with pointer to data buffer. This buffer resides in internal data structures of the <b>Session</b> object. After the callback returns, this buffer may be updated. It means, that the driving code may require to copy the buffer to its internal data structures to preserve the data intact until send over I/O link operation is complete.</p>
<h2><a class="anchor" id="cc_mqttsn_gw_session_page_send_client"></a>
Sending Data to Client</h2>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a0ae1e01456a2e22361627d02371f685f">setSendDataClientReqCb</a>(</div>
<div class="line">    [](<span class="keyword">const</span> std::uint8_t* buf, std::size_t bufLen)</div>
<div class="line">    {</div>
<div class="line">        ... </div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a0ae1e01456a2e22361627d02371f685f"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a0ae1e01456a2e22361627d02371f685f">cc_mqttsn_gateway::Session::setSendDataClientReqCb</a></div><div class="ttdeci">void setSendDataClientReqCb(SendDataReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when new data needs to be sent to the client.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_send_to_client(<span class="keywordtype">void</span>* userData, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> bufLen)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="gateway__all_8h.html#aa21ea0c1cb9dff11dd5ef85aee76b0bc">cc_mqttsn_gw_session_set_send_data_to_client_cb</a>(handle, &amp;my_send_to_client, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_aa21ea0c1cb9dff11dd5ef85aee76b0bc"><div class="ttname"><a href="gateway__all_8h.html#aa21ea0c1cb9dff11dd5ef85aee76b0bc">cc_mqttsn_gw_session_set_send_data_to_client_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_send_data_to_client_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionSendDataReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when new data needs to be sent to the client.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="cc_mqttsn_gw_session_page_send_broker"></a>
Sending Data to Broker</h2>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a56eaafc3518f45db61b4482cb7626464">setSendDataBrokerReqCb</a>(</div>
<div class="line">    [](<span class="keyword">const</span> std::uint8_t* buf, std::size_t bufLen)</div>
<div class="line">    {</div>
<div class="line">        ... </div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a56eaafc3518f45db61b4482cb7626464"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a56eaafc3518f45db61b4482cb7626464">cc_mqttsn_gateway::Session::setSendDataBrokerReqCb</a></div><div class="ttdeci">void setSendDataBrokerReqCb(SendDataReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when new data needs to be sent to the broker.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_send_to_broker(<span class="keywordtype">void</span>* userData, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> bufLen)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="gateway__all_8h.html#a01677e8c4af48a65450e1177de10a039">cc_mqttsn_gw_session_set_send_data_to_broker_cb</a>(handle, &amp;my_send_to_broker, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a01677e8c4af48a65450e1177de10a039"><div class="ttname"><a href="gateway__all_8h.html#a01677e8c4af48a65450e1177de10a039">cc_mqttsn_gw_session_set_send_data_to_broker_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_send_data_to_broker_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionSendDataReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when new data needs to be sent to the broker.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_time"></a>
Time Measurement</h1>
<p>The <b>Session</b> object may require to measure time to identify message delivery timeouts. It relies on the driving code to provide such service. There is a need to set appropriate callback:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session.<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#ad03abf3c8beaad947016bea6a5e66d85">setNextTickProgramReqCb</a>(</div>
<div class="line">    [](<span class="keywordtype">unsigned</span> duration)</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// Set timer to expire after duration milliseconds</span></div>
<div class="line">            <span class="comment">// After expiry call session.tick()</span></div>
<div class="line">    };</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ad03abf3c8beaad947016bea6a5e66d85"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ad03abf3c8beaad947016bea6a5e66d85">cc_mqttsn_gateway::Session::setNextTickProgramReqCb</a></div><div class="ttdeci">void setNextTickProgramReqCb(NextTickProgramReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when new time measurement is required.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_tick_req(<span class="keywordtype">void</span>* userData, <span class="keywordtype">unsigned</span> duration)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* Set timer to expire after duration milliseconds */</span></div>
<div class="line">    ... <span class="comment">/* After expiry call cc_mqttsn_gw_session_tick() */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="gateway__all_8h.html#a9a29a45cb621da2a929ce19aae3c0e35">cc_mqttsn_gw_session_set_tick_req_cb</a>(handle, &amp;my_tick_req, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a9a29a45cb621da2a929ce19aae3c0e35"><div class="ttname"><a href="gateway__all_8h.html#a9a29a45cb621da2a929ce19aae3c0e35">cc_mqttsn_gw_session_set_tick_req_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_tick_req_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionTickReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when new time measurement is required.</div></div>
</div><!-- fragment --><p>After the requested time expires, the driving code needs to notify the <b>Session</b> object. It must call the appropriate <b>tick()</b> function.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a3d3c252c3b9aa9572d2f8f52a4fee3a6">tick</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a3d3c252c3b9aa9572d2f8f52a4fee3a6"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a3d3c252c3b9aa9572d2f8f52a4fee3a6">cc_mqttsn_gateway::Session::tick</a></div><div class="ttdeci">void tick()</div><div class="ttdoc">Notify the Session object about requested time period expiry.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#a5e128249938a69f3c858adab44e81142">cc_mqttsn_gw_session_tick</a>(handle); </div>
<div class="ttc" id="agateway__all_8h_html_a5e128249938a69f3c858adab44e81142"><div class="ttname"><a href="gateway__all_8h.html#a5e128249938a69f3c858adab44e81142">cc_mqttsn_gw_session_tick</a></div><div class="ttdeci">void cc_mqttsn_gw_session_tick(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Notify the Session object about requested time period expiry.</div></div>
</div><!-- fragment --><p>Based on some events, the <b>Session</b> object may require knowledge of elapsed time since last tick programming request. For this purpose the driving code must set a callback to cancel the existing time measurement and return number of elapsed <b>milliseconds</b>.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a5219a534cc2f71375f1bba76e3819695">setCancelTickWaitReqCb</a>(</div>
<div class="line">    []()</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// cancel timer</span></div>
<div class="line">        <span class="keywordflow">return</span> ...; <span class="comment">// return number of elapsed milliseconds</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a5219a534cc2f71375f1bba76e3819695"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a5219a534cc2f71375f1bba76e3819695">cc_mqttsn_gateway::Session::setCancelTickWaitReqCb</a></div><div class="ttdeci">void setCancelTickWaitReqCb(CancelTickWaitReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when previously requested time measurement needs to be cancelled.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> my_cancel_timer_req(<span class="keywordtype">void</span>* userData)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* cancel timer */</span></div>
<div class="line">    <span class="keywordflow">return</span> ...; <span class="comment">/* return number of elapsed milliseconds */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="gateway__all_8h.html#a9d8d8ef98f2182880f4b1868602026c0">cc_mqttsn_gw_session_set_cancel_tick_cb</a>(handle, &amp;my_cancel_timer_req, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a9d8d8ef98f2182880f4b1868602026c0"><div class="ttname"><a href="gateway__all_8h.html#a9d8d8ef98f2182880f4b1868602026c0">cc_mqttsn_gw_session_set_cancel_tick_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_cancel_tick_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionCancelTickReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when previously requested time measurement needs to be cancelled.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_term"></a>
Session Termination</h1>
<p>The <b>Session</b> object may recognise disconnection of MQTT-SN client and/or MQTT broker. As the result the session object must be destructed immediately and new one is created once the client renews its connection. The request to terminate the session is performed via callback, which must be set by the driving code.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a7325fc0c10dc1cae59a6ff9a2252e7ee">setTerminationReqCb</a>(</div>
<div class="line">    []()</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// Destruct session object.</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a7325fc0c10dc1cae59a6ff9a2252e7ee"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a7325fc0c10dc1cae59a6ff9a2252e7ee">cc_mqttsn_gateway::Session::setTerminationReqCb</a></div><div class="ttdeci">void setTerminationReqCb(TerminationReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when the session needs to be terminated and this Session object delete...</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_session_term(<span class="keywordtype">void</span>* userData)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* Remove reference to session object from internal data structures */</span></div>
<div class="line">    <a class="code" href="gateway__all_8h.html#a988a27a795d74e569fe9be3dd93fbf2a">cc_mqttsn_gw_session_free</a>(handle);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="gateway__all_8h.html#a89e01f95470aefe80752c495d7b45268">cc_mqttsn_gw_session_set_term_req_cb</a>(handle, &amp;my_session_term, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a89e01f95470aefe80752c495d7b45268"><div class="ttname"><a href="gateway__all_8h.html#a89e01f95470aefe80752c495d7b45268">cc_mqttsn_gw_session_set_term_req_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_term_req_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionTermReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when the Session needs to be terminated and the calling Session object...</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_broker_reconnect"></a>
Re-Connection to Broker</h1>
<p>The <b>MQTT-SN</b> protocol specification defines messages and operations, that are not properly supported by the <b>MQTT</b> protocol, such as will information update. The <b>Session</b> object supports these kind of operations by sending updated <b>CONNECT</b> request to the broker on behalf of the client. However, MQTT protocol disallows multiple <b>CONNECT</b> messages in the single connection session. As the result the gateway must perform the following steps:</p>
<ol type="1">
<li>send <b>DISCONNECT</b> message</li>
<li>close existing TCP/IP connection</li>
<li>open new TCP/IP connection</li>
<li>send new <b>CONNECT</b> message with updated connection information.</li>
</ol>
<p>Due to the reason, that TCP/IP connection to the broker is managed by the driving code, it must implement steps 2 and 3 in the list above.</p>
<p>The <b>Session</b> object issues the reconnection request via callback, which must be provided by the driving code.</p>
<p><b>C++</b> interface </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a2db095effa29cff1497342e4e0d638ac">setBrokerReconnectReqCb</a>(</div>
<div class="line">    []()</div>
<div class="line">    {</div>
<div class="line">        ... <span class="comment">// Close existing TCP/IP connection to broker and open a new one</span></div>
<div class="line">    });</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a2db095effa29cff1497342e4e0d638ac"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a2db095effa29cff1497342e4e0d638ac">cc_mqttsn_gateway::Session::setBrokerReconnectReqCb</a></div><div class="ttdeci">void setBrokerReconnectReqCb(BrokerReconnectReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when the session needs to close existing TCP/IP connection to the brok...</div></div>
</div><!-- fragment --><p><b>C</b> interface </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_broker_reconnect(<span class="keywordtype">void</span>* userData)</div>
<div class="line">{</div>
<div class="line">    ... <span class="comment">/* Close existing TCP/IP connection to broker and open a new one */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="gateway__all_8h.html#a14fb2c660c6f321f061e99c66b343721">cc_mqttsn_gw_session_set_broker_reconnect_req_cb</a>(handle, &amp;my_broker_reconnect, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a14fb2c660c6f321f061e99c66b343721"><div class="ttname"><a href="gateway__all_8h.html#a14fb2c660c6f321f061e99c66b343721">cc_mqttsn_gw_session_set_broker_reconnect_req_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_broker_reconnect_req_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionBrokerReconnectReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when the Session needs to close existing TCP/IP connection to the brok...</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that the updated connection statuses of the broker (first disconnected and then connected) must be reported to the <b>Session</b> object when they happen. Details are in <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_broker_conn">Connection to Broker</a> section below.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_id"></a>
Gateway ID</h1>
<p>The MQTT-SN client may broadcast <b>SEARCHGW</b> message in an attempt to discover existing gateways on the network. The <b>Session</b> object is responsible to send <b>GWINFO</b> message as a response. Such message contains numeric gateway ID. Hence, the <b>Session</b> object must also be aware of the gateway ID information:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a6120e5c84cfa3e7a577c28ce5351cd2f">setGatewayId</a>(5);</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a6120e5c84cfa3e7a577c28ce5351cd2f"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a6120e5c84cfa3e7a577c28ce5351cd2f">cc_mqttsn_gateway::Session::setGatewayId</a></div><div class="ttdeci">void setGatewayId(std::uint8_t value)</div><div class="ttdoc">Set gateway numeric ID to be reported when requested.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#ab43525af01f83192fd7cb0c6297d3da3">cc_mqttsn_gw_session_set_id</a>(handle, 5);</div>
<div class="ttc" id="agateway__all_8h_html_ab43525af01f83192fd7cb0c6297d3da3"><div class="ttname"><a href="gateway__all_8h.html#ab43525af01f83192fd7cb0c6297d3da3">cc_mqttsn_gw_session_set_id</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_id(CC_MqttsnSessionHandle session, unsigned char id)</div><div class="ttdoc">Set gateway numeric ID to be reported when requested.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_retry"></a>
Retry Attempts</h1>
<p>There are cases when the communication to either client or broker is driven by the <b>Session</b> object itself. Such communication may involve messages that require acknowledgement by the other side. If acknowledgement is not received in time, the message must be re-sent. The <b>Session</b> object may be configured with duration (in <b>seconds</b>) between resend attempts and total number of attempts to perform.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a4159f98133b10a30982ee6c54e7c9be6">setRetryPeriod</a>(5U); <span class="comment">// 5 seconds between resend attempts</span></div>
<div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a65eea77d5c98b46c5ac12053976b0771">setRetryCount</a>(4U); <span class="comment">// up to 4 attempts to resend the same message</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a4159f98133b10a30982ee6c54e7c9be6"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a4159f98133b10a30982ee6c54e7c9be6">cc_mqttsn_gateway::Session::setRetryPeriod</a></div><div class="ttdeci">void setRetryPeriod(unsigned value)</div><div class="ttdoc">Set retry period to wait between resending unacknowledged message to the client and/or broker.</div></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a65eea77d5c98b46c5ac12053976b0771"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a65eea77d5c98b46c5ac12053976b0771">cc_mqttsn_gateway::Session::setRetryCount</a></div><div class="ttdeci">void setRetryCount(unsigned value)</div><div class="ttdoc">Set number of retry attempts to perform before abandoning attempt to send unacknowledged message.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#abd9a851d685fcac285aa3806d1865161">cc_mqttsn_gw_session_set_retry_period</a>(handle, 5U); <span class="comment">/* 5 seconds between resend attempts */</span></div>
<div class="line"><a class="code" href="gateway__all_8h.html#a46ae3079aeeefb1a07c688286543d62c">cc_mqttsn_gw_session_set_retry_count</a>(handle, 4U); <span class="comment">/* up to 4 attempts to resend the same message */</span></div>
<div class="ttc" id="agateway__all_8h_html_a46ae3079aeeefb1a07c688286543d62c"><div class="ttname"><a href="gateway__all_8h.html#a46ae3079aeeefb1a07c688286543d62c">cc_mqttsn_gw_session_set_retry_count</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_retry_count(CC_MqttsnSessionHandle session, unsigned value)</div><div class="ttdoc">Set number of retry attempts to perform before abandoning attempt to send unacknowledged message.</div></div>
<div class="ttc" id="agateway__all_8h_html_abd9a851d685fcac285aa3806d1865161"><div class="ttname"><a href="gateway__all_8h.html#abd9a851d685fcac285aa3806d1865161">cc_mqttsn_gw_session_set_retry_period</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_retry_period(CC_MqttsnSessionHandle session, unsigned value)</div><div class="ttdoc">Set retry period to wait between resending unacknowledged message to the client and/or broker.</div></div>
</div><!-- fragment --><p> If not configured, the default values of <b>10</b> seconds and <b>3</b> attempts apply.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_predefined_topics"></a>
Predefined Topics</h1>
<p>The messages in MQTT-SN protocol are published with numeric topic IDs instead of strings (like in original MQTT). The protocol also allows bypassing the topic strings registration and using predefined IDs directly. In this case the <b>Session</b> object must be configured with all known and applicable topic string and topic numeric ID pairs. It will use this information to convert between numeric topic ID topic topic string when forwarding <b>PUBLISH</b> messages to both directions.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a507b38d797b9e4d302ce4e9eb8acdee5">addPredefinedTopic</a>(<span class="stringliteral">&quot;some/predefined/topic&quot;</span>, 123)) {</div>
<div class="line">    ... <span class="comment">// report error</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a507b38d797b9e4d302ce4e9eb8acdee5">addPredefinedTopic</a>(<span class="stringliteral">&quot;other/predefined/topic&quot;</span>, 1111)) {</div>
<div class="line">    ... <span class="comment">// report error</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a507b38d797b9e4d302ce4e9eb8acdee5"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a507b38d797b9e4d302ce4e9eb8acdee5">cc_mqttsn_gateway::Session::addPredefinedTopic</a></div><div class="ttdeci">bool addPredefinedTopic(const std::string &amp;topic, std::uint16_t topicId)</div><div class="ttdoc">Add predefined topic string and ID information.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="gateway__all_8h.html#a065cabe188acc70ffc769372d41d8acc">cc_mqttsn_gw_session_add_predefined_topic</a>(handle, <span class="stringliteral">&quot;some/predefined/topic&quot;</span>, 123)) {</div>
<div class="line">    ... <span class="comment">/* report error */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code" href="gateway__all_8h.html#a065cabe188acc70ffc769372d41d8acc">cc_mqttsn_gw_session_add_predefined_topic</a>(handle, <span class="stringliteral">&quot;other/predefined/topic&quot;</span>, 1111)) {</div>
<div class="line">    ... <span class="comment">/* report error */</span></div>
<div class="line">}</div>
<div class="ttc" id="agateway__all_8h_html_a065cabe188acc70ffc769372d41d8acc"><div class="ttname"><a href="gateway__all_8h.html#a065cabe188acc70ffc769372d41d8acc">cc_mqttsn_gw_session_add_predefined_topic</a></div><div class="ttdeci">bool cc_mqttsn_gw_session_add_predefined_topic(CC_MqttsnSessionHandle session, const char *topic, unsigned short topicId)</div><div class="ttdoc">Add predefined topic string and ID information.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_topics_registration"></a>
Allocating Topic IDs</h1>
<p>When not using predefined topic IDs, there is a process of topic string registration and allocating relevant numeric topic ID. This allocation is performed by the <b>Session</b> object. By default the <b>Session</b> object will pick the first number available. However, it may be wise to reserve some range of topic IDs to be predefined ones, especially when there are some <b>client</b> <b>specific</b> predefined topic IDs, which added later when connected client ID is known (see <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_connected_client">Connected Client Report</a>). The library provides a way to limit range of topic IDs allocated during the registration process.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#adfe4fadd74fdf75b997f10604093d91e">setTopicIdAllocationRange</a>(0x1000, 0xffff)) {</div>
<div class="line">    ... <span class="comment">// report error</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_adfe4fadd74fdf75b997f10604093d91e"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#adfe4fadd74fdf75b997f10604093d91e">cc_mqttsn_gateway::Session::setTopicIdAllocationRange</a></div><div class="ttdeci">bool setTopicIdAllocationRange(std::uint16_t minVal, std::uint16_t maxVal)</div><div class="ttdoc">Limit range of topic IDs allocated for newly registered topics.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="gateway__all_8h.html#afab11f43de8774d1f460fc2488e3fa4b">cc_mqttsn_gw_session_set_topic_id_alloc_range</a>(handle, 0x1000, 0xffff)) {</div>
<div class="line">    ... <span class="comment">// report error</span></div>
<div class="line">}</div>
<div class="ttc" id="agateway__all_8h_html_afab11f43de8774d1f460fc2488e3fa4b"><div class="ttname"><a href="gateway__all_8h.html#afab11f43de8774d1f460fc2488e3fa4b">cc_mqttsn_gw_session_set_topic_id_alloc_range</a></div><div class="ttdeci">bool cc_mqttsn_gw_session_set_topic_id_alloc_range(CC_MqttsnSessionHandle session, unsigned short minTopicId, unsigned short maxTopicId)</div><div class="ttdoc">Limit range of topic IDs allocated for newly registered topics.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_start"></a>
Start Operation</h1>
<p>After been properly configured the <b>Session</b> object needs to be started.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a12513af6a5f2db6ebc57947771379bca">start</a>()) {</div>
<div class="line">    ... <span class="comment">// The session hasn&#39;t been properly configured, report error</span></div>
<div class="line">}</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a12513af6a5f2db6ebc57947771379bca"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a12513af6a5f2db6ebc57947771379bca">cc_mqttsn_gateway::Session::start</a></div><div class="ttdeci">bool start()</div><div class="ttdoc">Start this object's operation.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="gateway__all_8h.html#a338c5ca1a6a15590ca59c4e1d909e157">cc_mqttsn_gw_session_start</a>(handle)) {</div>
<div class="line">    ... <span class="comment">/* The session hasn&#39;t been properly configured, report error */</span></div>
<div class="line">}</div>
<div class="ttc" id="agateway__all_8h_html_a338c5ca1a6a15590ca59c4e1d909e157"><div class="ttname"><a href="gateway__all_8h.html#a338c5ca1a6a15590ca59c4e1d909e157">cc_mqttsn_gw_session_start</a></div><div class="ttdeci">bool cc_mqttsn_gw_session_start(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Start the Session's object's operation.</div></div>
</div><!-- fragment --><p> If not properly started, the <b>Session</b> object will ignore any input from client and broker.</p>
<p>The operation of the <b>Session</b> object can also be stopped / paused for a while.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#ae4a65f7acc2a8af7170daccc35278de5">stop</a>();</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ae4a65f7acc2a8af7170daccc35278de5"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ae4a65f7acc2a8af7170daccc35278de5">cc_mqttsn_gateway::Session::stop</a></div><div class="ttdeci">void stop()</div><div class="ttdoc">Stop the operation of the object.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#ab986ac42e699650ca4a772574c2a0438">cc_mqttsn_gw_session_stop</a>(handle);</div>
<div class="ttc" id="agateway__all_8h_html_ab986ac42e699650ca4a772574c2a0438"><div class="ttname"><a href="gateway__all_8h.html#ab986ac42e699650ca4a772574c2a0438">cc_mqttsn_gw_session_stop</a></div><div class="ttdeci">void cc_mqttsn_gw_session_stop(CC_MqttsnSessionHandle session)</div><div class="ttdoc">Stop the operation of the Session object.</div></div>
</div><!-- fragment --><p> The operation of the stopped <b>Session</b> object may be restarted using the same <a class="el" href="classcc__mqttsn__gateway_1_1Session.html#a12513af6a5f2db6ebc57947771379bca" title="Start this object&#39;s operation.">cc_mqttsn_gateway::Session::start()</a> and <a class="el" href="gateway__all_8h.html#a338c5ca1a6a15590ca59c4e1d909e157" title="Start the Session&#39;s object&#39;s operation.">cc_mqttsn_gw_session_start()</a> functions.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_broker_conn"></a>
Connection to Broker</h1>
<p><b>AFTER</b> (important emphasis here) successfully starting operation of the <b>Session</b> object (see <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_start">Start Operation</a>) the driving code must initiate TCP/IP connection to the MQTT broker. The driving code must also constantly monitor the state of this connection and to the <b>Session</b> object any detected change. When started, the <b>Session</b> object assumes broker is <b>disconnected</b>.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#ab3ce2cc8b3a964625a6b59c70ceb8a9c">setBrokerConnected</a>(<span class="keyword">true</span>); <span class="comment">// Reports broker being connected</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ab3ce2cc8b3a964625a6b59c70ceb8a9c"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ab3ce2cc8b3a964625a6b59c70ceb8a9c">cc_mqttsn_gateway::Session::setBrokerConnected</a></div><div class="ttdeci">void setBrokerConnected(bool connected)</div><div class="ttdoc">Notify the Session object about broker being connected / disconnected.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#abde1a8b4584ce9eda7d2f136d722eddb">cc_mqttsn_gw_session_broker_connected</a>(handle, <span class="keyword">true</span>); <span class="comment">// Reports broker being connected</span></div>
<div class="ttc" id="agateway__all_8h_html_abde1a8b4584ce9eda7d2f136d722eddb"><div class="ttname"><a href="gateway__all_8h.html#abde1a8b4584ce9eda7d2f136d722eddb">cc_mqttsn_gw_session_broker_connected</a></div><div class="ttdeci">void cc_mqttsn_gw_session_broker_connected(CC_MqttsnSessionHandle session, bool connected)</div><div class="ttdoc">Notify the Session object about broker being connected / disconnected.</div></div>
</div><!-- fragment --><p> When issuing broker re-connection request (see <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_broker_reconnect">Re-Connection to Broker</a>), the <b>Session</b> object expects this call to happen twice: the first one for disconnection report and second one for new connection report.</p>
<p>The driving code also responsible to detect unsolicited disconnects of TCP/IP link to the broker and report it to the <b>Session</b> object using the same function call.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_client_auth"></a>
Client Authentication</h1>
<p>The <b>MQTT</b> protocol supports client authentication, where the <b>CONNECT</b> message may contain username and password. The <b>MQTT-SN</b> protocol, on the other hand, lacks this feature. The <b>Session</b> object provides an ability to set a callback function, which will be invoked when MQTT-SN client's connection request is recognised. This callback may provide authentication information for this client, which is going to be filled in the forwarded <b>CONNECT</b> request.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#ab519faa29c6d2386e2b305fdb2289bbf">setAuthInfoReqCb</a>(</div>
<div class="line">    [](<span class="keyword">const</span> std::string&amp; clientId) -&gt; <a class="code" href="classcc__mqttsn__gateway_1_1Session.html#aa54812b289e8d1a3e75cd4bb35585588">cc_mqttsn_gateway::Session::AuthInfo</a></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_pair(getUsernameFor(clientId), getPasswordFor(clientId));</div>
<div class="line">        </div>
<div class="line">    }); </div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_aa54812b289e8d1a3e75cd4bb35585588"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#aa54812b289e8d1a3e75cd4bb35585588">cc_mqttsn_gateway::Session::AuthInfo</a></div><div class="ttdeci">std::pair&lt; std::string, BinaryData &gt; AuthInfo</div><div class="ttdoc">Type of authentication information.</div><div class="ttdef"><b>Definition:</b> Session.h:38</div></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ab519faa29c6d2386e2b305fdb2289bbf"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ab519faa29c6d2386e2b305fdb2289bbf">cc_mqttsn_gateway::Session::setAuthInfoReqCb</a></div><div class="ttdeci">void setAuthInfoReqCb(AuthInfoReqCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be used to request authentication information for specific client.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_auth_callback(</div>
<div class="line">    <span class="keywordtype">void</span>* userData, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* clientId, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>** username, </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>** password, </div>
<div class="line">    <span class="keywordtype">unsigned</span>* passwordLen)</div>
<div class="line">{</div>
<div class="line">    *username = ...; <span class="comment">/* assign pointer to username for provided client ID */</span></div>
<div class="line">    *password = ...; <span class="comment">/* assign pointer to password for provided client ID */</span></div>
<div class="line">    *passwordLen = ...; <span class="comment">/* specify length of the password */</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="gateway__all_8h.html#a6f97671aaae458452921533ee58868ad">cc_mqttsn_gw_session_set_auth_info_req_cb</a>(handle, &amp;my_auth_callback, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_a6f97671aaae458452921533ee58868ad"><div class="ttname"><a href="gateway__all_8h.html#a6f97671aaae458452921533ee58868ad">cc_mqttsn_gw_session_set_auth_info_req_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_auth_info_req_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionAuthInfoReqCb cb, void *data)</div><div class="ttdoc">Set the callback to be used to request authentication information for specific client.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_connected_client"></a>
Connected Client Report</h1>
<p>The <b>Session</b> object provides an ability to get notified when a MQTT-SN client is successfully connected. The notification is performed using a callback. Inside this callback, the driving code may provide some client specific configurations, such as new predefined topic IDs relevant only to the connected client.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#aa78b22f6b7144f598639160703376292">setClientConnectedReportCb</a>(</div>
<div class="line">    [session](<span class="keyword">const</span> std::string&amp; clientId)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a507b38d797b9e4d302ce4e9eb8acdee5">addPredefinedTopic</a>(<span class="stringliteral">&quot;client/specific/predefined/topic&quot;</span>, 2222)) {</div>
<div class="line">            ... <span class="comment">/* report error */</span></div>
<div class="line">        }</div>
<div class="line">    }); </div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_aa78b22f6b7144f598639160703376292"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#aa78b22f6b7144f598639160703376292">cc_mqttsn_gateway::Session::setClientConnectedReportCb</a></div><div class="ttdeci">void setClientConnectedReportCb(ClientConnectedReportCb &amp;&amp;func)</div><div class="ttdoc">Set the callback to be invoked when MQTT-SN client is successfully connected to the broker.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_client_connect_report(<span class="keywordtype">void</span>* userData, <span class="keyword">const</span> <span class="keywordtype">char</span>* clientId)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="gateway__all_8h.html#a065cabe188acc70ffc769372d41d8acc">cc_mqttsn_gw_session_add_predefined_topic</a>(handle, <span class="stringliteral">&quot;client/specific/predefined/topic&quot;</span>, 2222)) {</div>
<div class="line">        ... <span class="comment">/* report error */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code" href="gateway__all_8h.html#ad534980071149dcd84e31174bc4f36ab">cc_mqttsn_gw_session_set_client_connect_report_cb</a>(handle, &amp;my_client_connect_report, someUserData);</div>
<div class="ttc" id="agateway__all_8h_html_ad534980071149dcd84e31174bc4f36ab"><div class="ttname"><a href="gateway__all_8h.html#ad534980071149dcd84e31174bc4f36ab">cc_mqttsn_gw_session_set_client_connect_report_cb</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_client_connect_report_cb(CC_MqttsnSessionHandle session, CC_MqttsnSessionClientConnectReportCb cb, void *data)</div><div class="ttdoc">Set the callback to be invoked when MQTT-SN client is successfully connected to the broker.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="cc_mqttsn_gw_session_page_default_client_id"></a>
Default Client ID</h1>
<p>The <b>Session</b> object interface allows to specify the default ID of the client, which is going to be used to connect to broker, if the client doesn't provide non-empty ID string in its connection attempt. This may be useful when client is connected over one-to-one I/O link such as <b>RS-232</b>. In order to simplify the client implementation and reduce amount of data transferred on the link, the <b>Session</b> object may be configured to substitute the empty client ID with other, non-empty one, when forwarding the connection request to the broker.</p>
<p>The default client ID configuration may also be used with "publish
only" clients (see <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_publish_only">Publish Only Client</a> below). The configured client ID will be used when connecting to the broker on behalf of the "publish only" client.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a31a9ce1bc29973c0659044f752ff3d14">setDefaultClientId</a>(<span class="stringliteral">&quot;some_default_id&quot;</span>);</div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a31a9ce1bc29973c0659044f752ff3d14"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a31a9ce1bc29973c0659044f752ff3d14">cc_mqttsn_gateway::Session::setDefaultClientId</a></div><div class="ttdeci">void setDefaultClientId(const std::string &amp;value)</div><div class="ttdoc">Provide default client ID for clients that report empty one in their attempt to connect.</div></div>
</div><!-- fragment --><p><b>C</b> interface: </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#ae3bc2ab5acee7ee27bc17aa0cf98ab7f">cc_mqttsn_gw_session_set_default_client_id</a>(handle, <span class="stringliteral">&quot;some_default_id&quot;</span>);</div>
<div class="ttc" id="agateway__all_8h_html_ae3bc2ab5acee7ee27bc17aa0cf98ab7f"><div class="ttname"><a href="gateway__all_8h.html#ae3bc2ab5acee7ee27bc17aa0cf98ab7f">cc_mqttsn_gw_session_set_default_client_id</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_default_client_id(CC_MqttsnSessionHandle session, const char *clientId)</div><div class="ttdoc">Provide default client ID for clients that report empty one in their attempt to connect.</div></div>
</div><!-- fragment --><p> <b>NOTE</b>, that the <b>Session</b> object will make an attempt to substitute reported client ID <b>if and only if</b> the client ID <b>is</b> empty and configured default client ID is <b>NOT</b>.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_publish_only"></a>
Publish Only Client</h1>
<p>The MQTT-SN protocol allows "publish only" clients, which don't make an attempt to connect to the gateway/broker, but allowed to publish messages with predefined topic IDs and QoS=-1. The gateway must connect to the broker on behalf of such client. The connection operation involves knowledge about client ID and "keep alive" period. The client ID, that is going to be used, is configured as <a class="el" href="cc_mqttsn_gw_session_page.html#cc_mqttsn_gw_session_page_default_client_id">Default Client ID</a>. The "keep alive" period can be provided using separate function:</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#ad9933a5769200858d7faa2bf1f374d82">setPubOnlyKeepAlive</a>(100); <span class="comment">// 100 seconds</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_ad9933a5769200858d7faa2bf1f374d82"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#ad9933a5769200858d7faa2bf1f374d82">cc_mqttsn_gateway::Session::setPubOnlyKeepAlive</a></div><div class="ttdeci">void setPubOnlyKeepAlive(std::uint16_t value)</div><div class="ttdoc">Provide default &quot;keep alive&quot; period for &quot;publish only&quot; clients, that do not make an attempt to connec...</div></div>
</div><!-- fragment --><p><b>C++</b> interface: </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#a4ec46b242b81d482ca6b71b15a0ecfc8">cc_mqttsn_gw_session_set_pub_only_keep_alive</a>(handle, 100); <span class="comment">/* 100 seconds */</span></div>
<div class="ttc" id="agateway__all_8h_html_a4ec46b242b81d482ca6b71b15a0ecfc8"><div class="ttname"><a href="gateway__all_8h.html#a4ec46b242b81d482ca6b71b15a0ecfc8">cc_mqttsn_gw_session_set_pub_only_keep_alive</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_pub_only_keep_alive(CC_MqttsnSessionHandle session, unsigned value)</div><div class="ttdoc">Provide default &quot;keep alive&quot; period for &quot;publish only&quot; clients, that do not make an attempt to connec...</div></div>
</div><!-- fragment --><p> If such configuration is not provided, the default value of <b>60</b> seconds is assumed.</p>
<h1><a class="anchor" id="cc_mqttsn_gw_session_page_sleep"></a>
Sleeping Client</h1>
<p>The <b>Session</b> object supports client entering the <b>SLEEP</b> mode without any extra configuration. It will send the <b>PINGREQ</b> messages on behalf of the client to keep the connection to the broker alive, and will accumulate all the messages sent to the client until it wakes up.</p>
<p>However, it may be a good idea to limit the number of messages, the <b>Session</b> object is allowed to accumulate, to avoid consumption of too much memory.</p>
<p><b>C++</b> interface: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="classcc__mqttsn__gateway_1_1Session.html#a0b96e11b66b6ece04f8a331c9b72600c">setSleepingClientMsgLimit</a>(1000); <span class="comment">// no more that 1000 messages</span></div>
<div class="ttc" id="aclasscc__mqttsn__gateway_1_1Session_html_a0b96e11b66b6ece04f8a331c9b72600c"><div class="ttname"><a href="classcc__mqttsn__gateway_1_1Session.html#a0b96e11b66b6ece04f8a331c9b72600c">cc_mqttsn_gateway::Session::setSleepingClientMsgLimit</a></div><div class="ttdeci">void setSleepingClientMsgLimit(std::size_t value)</div><div class="ttdoc">Provide limit to number pending messages being accumulated for the sleeping client.</div></div>
</div><!-- fragment --><p><b>C++</b> interface: </p><div class="fragment"><div class="line"><a class="code" href="gateway__all_8h.html#ad4c4a37615011d8e08ef4cea5bdfba2b">cc_mqttsn_gw_session_set_sleeping_client_msg_limit</a>(handle, 1000); <span class="comment">/* no more that 1000 messages */</span></div>
<div class="ttc" id="agateway__all_8h_html_ad4c4a37615011d8e08ef4cea5bdfba2b"><div class="ttname"><a href="gateway__all_8h.html#ad4c4a37615011d8e08ef4cea5bdfba2b">cc_mqttsn_gw_session_set_sleeping_client_msg_limit</a></div><div class="ttdeci">void cc_mqttsn_gw_session_set_sleeping_client_msg_limit(CC_MqttsnSessionHandle session, unsigned value)</div><div class="ttdoc">Provide limit to number pending messages being accumulated for the sleeping client.</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 12 2024 08:40:21 for MQTT-SN Gateway Library by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
